services:
  # API Gateway - handles HTTP requests and coordinates workflow
  api:
    build: ./services/api
    image: audiobook-api:latest
    expose:
      - "8000"  # Expose to internal network only
    env_file:
      - .env
    environment:
      STORAGE_URL: "http://storage:8001"
      REDIS_URL: "${REDIS_URL}"
      CORS_ORIGINS: "${CORS_ORIGINS}"
      API_BASE_URL: "${API_BASE_URL}"
      DEBUG: "true"
      SECRET_KEY: "${SECRET_KEY:-your-secret-key-for-jwt-signing}"
      PASSWORD_RESET_EXPIRY: "${PASSWORD_RESET_EXPIRY:-15}"
      SIGNED_URL_EXPIRY: "${SIGNED_URL_EXPIRY:-3600}"
      USER_QUEUE_NAME: "${USER_QUEUE_NAME}"
      USER_RESPONSE_QUEUE_NAME: "${USER_RESPONSE_QUEUE_NAME}"
    volumes:
      - text_data:/data/text  # Shared text storage for processing pipeline
      - segment_data:/data/ogg:ro  # Read-only access to serve audio chunks
      - meta_data:/data/meta  # Database and metadata storage
    depends_on:
      - storage
      - redis
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - evocable-network

  # Centralized storage and metadata management
  storage:
    build: ./services/storage
    image: audiobook-storage:latest
    user: root
    expose:
      - "8001"  # Expose to internal network only
    env_file:
      - .env
    environment:
      DATABASE_URL: "${DATABASE_URL}"
      TEXT_DATA_PATH: "${TEXT_DATA_PATH}"
      WAV_DATA_PATH: "${WAV_DATA_PATH}"
      SEGMENT_DATA_PATH: "${SEGMENT_DATA_PATH}"
      META_DATA_PATH: "${META_DATA_PATH}"
      USER_QUEUE_NAME: "${USER_QUEUE_NAME}"
      USER_RESPONSE_QUEUE_NAME: "${USER_RESPONSE_QUEUE_NAME}"
    volumes:
      - text_data:/data/text
      - wav_data:/data/wav
      - segment_data:/data/ogg
      - meta_data:/data/meta
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8001/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - evocable-network

  # Message broker for service coordination
  redis:
    image: redis:7-alpine
    expose:
      - "6379"  # Expose to internal network only
    env_file:
      - .env
    environment:
      REDIS_URL: "${REDIS_URL}"
    volumes:
      - redis_data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - evocable-network

  # Text extraction service - triggered by API
  ingest:
    build: ./services/ingest
    image: audiobook-ingest:latest
    env_file:
      - .env
    environment:
      STORAGE_URL: "http://storage:8001"
      REDIS_URL: "${REDIS_URL}"
      QUEUE_NAME: "${INGEST_QUEUE_NAME}"
      TEXT_DATA_PATH: "${TEXT_DATA_PATH}"
    volumes:
      - text_data:/data/text
    depends_on:
      storage:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "python", "-c", "import asyncio; from main import TextExtractor; extractor = TextExtractor('http://storage:8001', 'redis://redis:6379'); print(asyncio.run(extractor.health_check()))"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 30s
    networks:
      - evocable-network

  # Text segmentation service - triggered by ingest completion
  segmenter:
    build: ./services/segmenter
    image: audiobook-segmenter:latest
    env_file:
      - .env
    environment:
      STORAGE_URL: "http://storage:8001"
      REDIS_URL: "${REDIS_URL}"
      QUEUE_NAME: "${SEGMENT_QUEUE_NAME}"
      CHUNK_SIZE_CHARS: "${CHUNK_SIZE_CHARS}"
      TEXT_DATA_PATH: "${TEXT_DATA_PATH}"
    volumes:
      - text_data:/data/text:ro
    depends_on:
      storage:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "python", "-c", "import spacy; spacy.load('en_core_web_sm')"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 30s
    networks:
      - evocable-network

  # TTS processing service - triggered by segmentation completion
  tts-worker:
    build: ./services/tts-worker
    image: audiobook-tts:latest
    env_file:
      - .env
    environment:
      STORAGE_URL: "http://storage:8001"
      REDIS_URL: "${REDIS_URL}"
      QUEUE_NAME: "${TTS_QUEUE_NAME}"
      TTS_MODEL: "tts_models/en/ljspeech/tacotron2-DDC"
      WAV_DATA_PATH: "${WAV_DATA_PATH}"
      MODEL_PATH: "${MODEL_PATH}"
      NVIDIA_VISIBLE_DEVICES: "${NVIDIA_VISIBLE_DEVICES}"
      NVIDIA_DRIVER_CAPABILITIES: "${NVIDIA_DRIVER_CAPABILITIES}"
    volumes:
      - text_data:/data/text:ro  # Read SSML chunks
      - wav_data:/data/wav       # Write WAV files
    depends_on:
      storage:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "python", "-c", "import torch; print('GPU available:', torch.cuda.is_available())"]
      interval: 60s
      timeout: 30s
      retries: 3
      start_period: 120s
    networks:
      - evocable-network

  # Audio transcoding service - triggered by TTS completion
  transcoder:
    build: ./services/transcoder
    image: audiobook-transcoder:latest
    env_file:
      - .env
    environment:
      STORAGE_URL: "http://storage:8001"
      REDIS_URL: "${REDIS_URL}"
      QUEUE_NAME: "${TRANSCODE_QUEUE_NAME}"
      SEGMENT_DURATION: "${SEGMENT_DURATION}"
      OPUS_BITRATE: "${OPUS_BITRATE}"
      WAV_DATA_PATH: "${WAV_DATA_PATH}"
      SEGMENT_DATA_PATH: "${SEGMENT_DATA_PATH}"
    volumes:
      - wav_data:/data/wav:ro
      - segment_data:/data/ogg
    depends_on:
      storage:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "ffmpeg", "-version"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 30s
    networks:
      - evocable-network

  # Test runner service - runs tests inside Docker network
  test:
    build: 
      context: .
      dockerfile: Dockerfile.test
    env_file:
      - .env
    environment:
      SECRET_KEY: "${SECRET_KEY:-test-jwt-secret-key-change-in-production}"
      DATABASE_PATH: "/tmp/test_audiobooks.db"
      DATABASE_URL: "sqlite:///:memory:"
      REDIS_URL: "${REDIS_URL}"
      STORAGE_URL: "http://storage:8001"  # Internal HTTP for storage service
      INGEST_URL: "http://ingest:8002"
      CORS_ORIGINS: "${CORS_ORIGINS}"
      DEBUG: "true"
      PASSWORD_RESET_EXPIRY: "${PASSWORD_RESET_EXPIRY:-15}"
      RATE_LIMIT_STORAGE_URL: "${REDIS_URL}"
      API_BASE_URL: "${API_BASE_URL}"  # Use environment variable from .env
    volumes:
      - .:/app
      - /app/ENV
    depends_on:
      - api
      - storage  # Back to regular storage dependency
      - redis
    networks:
      - evocable-network
    command: ["python", "tests/run_tests.py"]

volumes:
  text_data:
  wav_data:
  segment_data:
  meta_data:
  redis_data:
  tts_models:

networks:
  evocable-network:
    external: true
    name: evocable-network
